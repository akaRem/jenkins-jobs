#!/usr/bin/env python
#
# This script is used to delete old systests from slaves
# It requires jobs.txt file generated by cleaner_jobs.py with
# list of all jobs on slaves
#
# Delete procedure:
#  - skip all protected jobs (env_*)
#  - skip environments younger then global minimal lifetime
#  - skip jobs not executed by jenkins
#  - skip jobs which looks like latest execution in jenkins, start/execution
#    time less then 1 h (can be omited by protect_latest)
#  - delete all job older then max lifetime
#

import datetime
import os
import re
import subprocess


_boolean_states = {'1': True, 'yes': True, 'true': True, 'on': True,
                   '0': False, 'no': False, 'false': False, 'off': False}


def get_var_as_bool(name, default):
    value = os.environ.get(name, '')
    return _boolean_states.get(value.lower(), default)

#
# Definition for known systests, this dictionary should contain all known
# systest types. Each dictionary should have:
#  * env_regexp - regexp used to compare with env_prefix
#  * lifetime - time after which we can delete this job
#  * protect_latest - allow to enable protection for latest job executions,
#                     when enabled skip jobs with execution time similar
#                     to latest jenkins job execution, such env are deleted
#                     after lifetime_max
#
tests_list = {

    # SWARM tests, executed every day,
    # should be deleted before next swarm run
    'swarm': {
        'env_regexp': '.*system_test.*',
        'lifetime': int(os.environ.get('LIFETIME_SWARM', 22)),
        'protect_latest': False,
    },

    # BVT tests executed on every iso build, executed few times per day
    # those tests are very important and when failed are investigated asap
    # by developers, can be deleted after 24h
    'bvt': {
        'env_regexp': '.*main.*',
        'lifetime': int(os.environ.get('LIFETIME_BVT', 24)),
        'protect_latest': True,
    },

    # Acceptance tests executed every week
    # should be investigated by QA team before next run
    # cannot be deleted before next acceptance test, need to store
    # at least 7 days
    'acceptance': {
        'env_regexp': '.*acceptance.*',
        'lifetime': int(os.environ.get('LIFETIME_ACCEPTANCE', 168)),
        'protect_latest': False,
    },

}

# Default lifetime for not specified tests
lifetime_other = int(os.environ.get('LIFETIME_OTHER', 16))

# Define minimal safety lifetime, we dont want to delete fresh systems,
# defined in hours
lifetime_minimal = 6

# Define maximum lifetime, this is used for jobs which are protected by
# protect_latest variable, latest protection is not respected for enviroments
# which are longer then max lifetime
lifetime_max = 120


class Cleaner():
    def __init__(self):

        # Get job list from jobs.txt and prepare dictionary with run parameters
        self.prefixes = {}
        with open('jobs.txt', 'r') as jobs_all:
            for job in jobs_all:

                # Get job parameters
                job_name, env_prefix, last_ts_txt = job.strip().split()

                # Skip jobs without execution, it should not exists on slaves
                if last_ts_txt == 'None':
                    continue

                last_ts = \
                    datetime.datetime.fromtimestamp(float(last_ts_txt)/1000)
                self.prefixes[env_prefix] = {
                    'job_name': job_name,
                    'latest_timestamp': last_ts.replace(microsecond=0),
                }

        # prepare list of devops envs to iterate
        self.devops = []
        if get_var_as_bool('DEVOPS_2_9', True):
            self.devops.append('/home/jenkins/venv-nailgun-tests-2.9')
        if get_var_as_bool('DEVOPS_2_5', False):
            self.devops.append('/home/jenkins/venv-nailgun-tests')
        if get_var_as_bool('RELEASE_60', False):
            self.devops.append('/home/jenkins/qa-venv-6.0')
        if get_var_as_bool('RELEASE_61', False):
            self.devops.append('/home/jenkins/qa-venv-6.1')

    def start(self):
        # cleaner itself
        for devops_path in self.devops:
            print(70*'=')
            print 'Changing environment to: ({})'.format(devops_path)
            print(70*'=')

            # get list of local environments
            dos_path = "%s/bin/dos.py" % devops_path

            # skip non existent environment
            if not os.path.isfile(dos_path):
                print 'WARNING: VENV {} does not exists'.format(devops_path)
                continue

            local_environments = subprocess.check_output(
                [dos_path, 'list', '--timestamp']
                ).split('\n')[:-1]
            # workaround if header added
            if local_environments and local_environments[0].startswith('NAME'):
                local_environments = local_environments[2:]

            print 'Local environments found:'
            print '\n'.join('- {}'.format(x) for x in local_environments)

            for env in local_environments:
                # try to get verified data first
                try:
                    env_name, timestamp_env_local_text = env.split()
                    # get env execution time on this slave
                    timestamp_env_local = datetime.datetime.strptime(
                        timestamp_env_local_text.split('.')[0],
                        '%Y-%m-%d_%H:%M:%S'
                        ).replace(microsecond=0)
                except:
                    print 'WARNING: problem with analyse env: {}'.format(env)
                    continue

                print '\nAnalyzing {} environment:'.format(env_name)

                # Skip protected environemts
                if env_name.startswith('env_'):
                    print '- environment is env_* - skipping'
                    continue

                # Get lifetime for this type of env
                (env_lifetime_hours, env_protect_latest) = \
                    self.get_job_lifetime(env_name)

                # get local slave time
                timestamp_now = datetime.datetime.now().replace(microsecond=0)

                # when older then lifetime check if ready to erase
                if (timestamp_now - timestamp_env_local) > \
                        datetime.timedelta(hours=env_lifetime_hours):
                    print '- older then required {}h ({})'.format(
                        env_lifetime_hours,
                        timestamp_env_local,
                        )
                    env_prefix = self.get_prefix_by_env_name(env_name)

                    # Skip environment without jenkins job
                    if not env_prefix:
                        print '- job not started by jenkins!!'
                        continue

                    # Get latests jenkins job execution for this prefix
                    timestamp_env_latest = \
                        self.prefixes[env_prefix]['latest_timestamp']
                    print '- jenkins job = {}'.format(
                        self.prefixes[env_prefix]['job_name']
                        )

                    print '- timestamp_env_local = %s' % timestamp_env_local
                    print '- timestamp_env_latest = %s' % timestamp_env_latest

                    # Check minimal lifetime
                    if (timestamp_now - timestamp_env_local) < \
                            datetime.timedelta(hours=lifetime_minimal):
                        time_diff = timestamp_now - timestamp_env_local
                        print '- skip - this build is too young,' \
                              ' only {}s, {}s required'.format(
                                  time_diff.seconds,
                                  lifetime_minimal * 3600
                              )
                        continue

                    # Check latest job protection, if is set we will not delete
                    # envs which have time execution similar to latest job
                    # start
                    # Additionaly check max lifetime, if job is older we can
                    # deleted it
                    time_diff_latest = \
                        timestamp_env_local - timestamp_env_latest
                    time_diff_max = timestamp_now - timestamp_env_local
                    if not env_protect_latest or \
                       time_diff_latest > datetime.timedelta(hours=1) or \
                       time_diff_max > datetime.timedelta(hours=lifetime_max):
                        print '- remove - this build is safe to remove'
                        self.local_remove_env(dos_path, env_name)
                    else:
                        time_diff = timestamp_env_local - timestamp_env_latest
                        print '- skip - this build is close to latest build,' \
                              ' only {}s, {}s required'.format(
                                  time_diff.seconds,
                                  lifetime_minimal * 3600
                              )
                else:
                    time_diff = timestamp_now - timestamp_env_local
                    print '- skip - need {}h to analyse,' \
                          ' only {}h old ({})'.format(
                              env_lifetime_hours,
                              int(time_diff.total_seconds() / 3600),
                              timestamp_env_local
                          )

    def get_job_lifetime(self, env_prefix):
        """
        Select lifetime, based on job prefix
        """
        for param_name, param in tests_list.items():
            if re.match(param['env_regexp'], env_prefix):
                return (param['lifetime'], param['protect_latest'])
        return (lifetime_other, False)

    def get_prefix_by_env_name(self, env_name):
        """ get server job by local (probably suffixed) name """
        all_prefixes = self.prefixes.keys()
        # catch empty job list
        if not len(all_prefixes):
            return None
        all_prefixes.sort(key=len, reverse=True)
        for env_prefix in all_prefixes:
            if env_name.startswith(env_prefix):
                return env_prefix

    def local_remove_env(self, dos_path, env_name):
        print 'Removing: {}'.format(env_name)
        subprocess.check_output([dos_path, 'erase', env_name])

if __name__ == "__main__":
    cleaner = Cleaner()
    cleaner.start()
